#!/usr/bin/env npx tsx
/**
 * Generate static pricing cache from Helicone and OpenRouter APIs
 * 
 * Usage: pnpm generate-pricing-cache
 * 
 * This script fetches current model lists and pricing from external APIs
 * and writes them to apps/background/src/utils/pricing-cache.ts
 * 
 * Data Sources:
 * - Helicone: https://helicone.ai/api/llm-costs (no API key required)
 * - OpenRouter: https://openrouter.ai/api/v1/models (no API key required)
 */

import * as fs from 'fs';
import * as path from 'path';

const HELICONE_PROVIDERS = ['openai', 'anthropic', 'google', 'x'] as const;
const HELICONE_PROVIDER_MAP: Record<string, string> = {
  openai: 'openai',
  anthropic: 'anthropic',
  google: 'gemini',
  x: 'grok',
};

interface HeliconeModel {
  model: string;
  input_cost_per_1m: number;
  output_cost_per_1m: number;
}

interface OpenRouterModel {
  id: string;
  pricing?: { prompt: string; completion: string };
}

async function fetchHeliconeData(provider: string): Promise<{ models: string[]; pricing: Record<string, { inputPerToken: number; outputPerToken: number }> }> {
  try {
    const res = await fetch(`https://helicone.ai/api/llm-costs?provider=${provider}`);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    
    const models = [...new Set(data.data.map((m: HeliconeModel) => m.model))] as string[];
    const pricing: Record<string, { inputPerToken: number; outputPerToken: number }> = {};
    
    for (const entry of data.data as HeliconeModel[]) {
      pricing[entry.model] = {
        inputPerToken: entry.input_cost_per_1m / 1_000_000,
        outputPerToken: entry.output_cost_per_1m / 1_000_000,
      };
    }
    
    return { models, pricing };
  } catch (e) {
    console.error(`Failed to fetch Helicone data for ${provider}:`, e);
    return { models: [], pricing: {} };
  }
}

async function fetchOpenRouterData(): Promise<{ groups: Array<{ id: string; displayName: string; models: string[] }>; pricing: Record<string, { inputPerToken: number; outputPerToken: number }> }> {
  try {
    const res = await fetch('https://openrouter.ai/api/v1/models');
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    
    const groupMap = new Map<string, string[]>();
    const pricing: Record<string, { inputPerToken: number; outputPerToken: number }> = {};
    
    const PROVIDER_NAMES: Record<string, string> = {
      openai: 'OpenAI', anthropic: 'Anthropic', google: 'Google',
      'meta-llama': 'Meta Llama', mistralai: 'Mistral', 'x-ai': 'xAI',
      deepseek: 'DeepSeek', cohere: 'Cohere', perplexity: 'Perplexity',
    };
    
    for (const model of data.data as OpenRouterModel[]) {
      if (model.id.endsWith(':free') || model.id.includes(':extended')) continue;
      
      const providerId = model.id.includes('/') ? model.id.split('/')[0] : 'other';
      if (!groupMap.has(providerId)) groupMap.set(providerId, []);
      groupMap.get(providerId)!.push(model.id);
      
      const inputCost = parseFloat(model.pricing?.prompt || '0');
      const outputCost = parseFloat(model.pricing?.completion || '0');
      if (!isNaN(inputCost) && !isNaN(outputCost)) {
        pricing[model.id] = { inputPerToken: inputCost, outputPerToken: outputCost };
      }
    }
    
    const groups = Array.from(groupMap.entries())
      .map(([id, models]) => ({
        id,
        displayName: PROVIDER_NAMES[id] || id.charAt(0).toUpperCase() + id.slice(1),
        models: models.sort(),
      }))
      .sort((a, b) => a.displayName.localeCompare(b.displayName));
    
    return { groups, pricing };
  } catch (e) {
    console.error('Failed to fetch OpenRouter data:', e);
    return { groups: [], pricing: {} };
  }
}

async function main() {
  console.log('Fetching pricing data from APIs...\n');
  
  // Fetch Helicone data for each provider
  const heliconeData: Record<string, { models: string[]; pricing: Record<string, { inputPerToken: number; outputPerToken: number }> }> = {};
  
  for (const provider of HELICONE_PROVIDERS) {
    console.log(`Fetching Helicone data for ${provider}...`);
    const data = await fetchHeliconeData(provider);
    const mappedName = HELICONE_PROVIDER_MAP[provider];
    heliconeData[mappedName] = data;
    console.log(`  → ${data.models.length} models, ${Object.keys(data.pricing).length} with pricing`);
  }
  
  // Fetch OpenRouter data
  console.log('\nFetching OpenRouter data...');
  const openRouterData = await fetchOpenRouterData();
  console.log(`  → ${openRouterData.groups.length} providers, ${Object.keys(openRouterData.pricing).length} models with pricing`);
  
  // Generate the cache file
  const generatedAt = new Date().toISOString();
  
  const fileContent = `/**
 * Static pricing cache - bundled with extension for offline/privacy mode
 * 
 * This file is auto-generated by live_data/generate-pricing-cache.ts
 * Run: pnpm generate-pricing-cache
 * 
 * When useLivePricingData is false, the extension uses this cached data
 * instead of making external API calls to Helicone and OpenRouter.
 */

export interface CachedProviderData {
  models: string[];
  pricing: Record<string, { inputPerToken: number; outputPerToken: number }>;
}

export interface CachedOpenRouterGroup {
  id: string;
  displayName: string;
  models: string[];
}

export interface CachedPricingData {
  generatedAt: string;
  version: number;
  helicone: Record<string, CachedProviderData>;
  openRouter: {
    groups: CachedOpenRouterGroup[];
    pricing: Record<string, { inputPerToken: number; outputPerToken: number }>;
  };
}

// Cache generated on ${generatedAt.split('T')[0]} - Update by running: pnpm generate-pricing-cache
export const CACHED_PRICING_DATA: CachedPricingData = ${JSON.stringify({
    generatedAt,
    version: 1,
    helicone: heliconeData,
    openRouter: openRouterData,
  }, null, 2)};
`;

  const outputPath = path.join(__dirname, '../apps/background/src/utils/pricing-cache.ts');
  fs.writeFileSync(outputPath, fileContent);
  
  console.log(`\n✓ Cache written to ${outputPath}`);
  console.log(`  Generated at: ${generatedAt}`);
}

main().catch(console.error);
